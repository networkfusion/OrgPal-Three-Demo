using System;
using System.Collections;
using System.Text;
using System.Device.Gpio;
using System.Device.I2c;

namespace PalThree
{
    /// <summary>Various helper methods and constants.</summary>
    public class PalHelper
    {

        public static ArrayList FindDevices(int I2CId, byte minimumAddress = 0x08, byte maximumAddress = 0x77)
        {
            ArrayList returnValue = new ArrayList();

            if (I2CId != 0) //TODO: check...
            {

                for (byte address = minimumAddress; address <= maximumAddress; address++)
                {

                    using (I2cDevice device = new I2cDevice(new I2cConnectionSettings(I2CId, address, I2cBusSpeed.StandardMode)))
                    {
                        try
                        {
                            var result = device.WriteByte(0x00);
                            if (result.Status == I2cTransferStatus.FullTransfer || result.Status == I2cTransferStatus.PartialTransfer)
                                returnValue.Add(address);
                        }
                        catch
                        {

                        }
                    }
                }
            }

            return returnValue;
        }

        public static byte[] GenerateMAC()
        {
            byte[] b = new byte[1];
            Random rnd = new Random();
            //6C:C8:7E:F3:11:65
            byte[] mac = new byte[] { 0x90, 0xA2, 0xDA, 0x00, 0x00, 0x00 };

            //generate only last 3 sets of values
            for (int i = 3; i < 6; i++)
            {
                rnd.NextBytes(b);
                mac[i] = b[0];
            }
            return mac;
        }

        public static byte[] GenerateUniqueMacAddr(string myUniqueId = "OrgPal")
        {
            var myMac = new byte[6];
            //generate a random based on a fixed seed this will guarantee that we get the 
            //same Random number everytime based on the provided string... make your string UNIQUE...
            //This would be great if only each board had a UNIQUE SERIAL NUmber ahhhhhh...          
            var r = myUniqueId != null ? new Random(myUniqueId.GetHashCode()) : new Random();
            // fill the newly generated bytes into the variable
            r.NextBytes(myMac);
            // update the last bit of the first byte with 1 which will flg the Mac as a Locally administered Mac address...
            //Please share if you have a better way of doing this.
            myMac[0] = (byte)(myMac[0] | 0x01);
            //shift to the left by 1 which will give 10 on the last two bits of the first byte... 0 on the last bit means UNICAST Mac Address.
            myMac[0] = (byte)(myMac[0] << 1);
            return myMac;
        }

        /// <summary>
        /// Scales a value from 4-20mA to a physcial value using the standard formula.
        /// </summary>
        /// <param name="physicalHigh"></param>
        /// <param name="physicalLow"></param>
        /// <param name="Ilow"></param>
        /// <param name="Ihigh"></param>
        /// <returns></returns>
        /// <example>
        /// 
        /// //1. read value when expected output is from 2 to 12  pH value for example
        /// float phValue = Current4to20ToPhysicalValueScaling(pal.Get420mAValue(), 12, 2);
        /// 
        ///  //2. read value when expected output is from 0 to 6340 Gallons
        /// float phValue = Current4to20ToPhysicalValueScaling(pal.Get420mAValue(), 6340);
        /// 
        /// </example>
        public static float Current4to20ToPhysicalValueScaling(float input4to20Val, float physicalHigh, float physicalLow = 0, float Ilow = 4, float Ihigh = 20)
        {
            //returns the physical value 
            return (physicalHigh - physicalLow) / (Ihigh - Ilow) * (input4to20Val - Ilow) + physicalLow;
        }



        public static float TankRoundCylinderLevelVolume(float height, float length, float radius, float radiusEndCapLeft, float radiusEndCapRight)
        {
            float volEndCapLeft = 0, volEndCapRight = 0;

            float volCylinder = RoundCylinderPartialVolume(height, radius, length);

            if (radiusEndCapLeft > 0)
                volEndCapLeft = EndCapPartialVolume(height, radiusEndCapLeft, radius);
            if (radiusEndCapRight > 0)
                volEndCapRight = EndCapPartialVolume(height, radiusEndCapRight, radius);

            return volCylinder + volEndCapRight + volEndCapLeft;
        }


        public static float TankRoundCylinderFullVolume(float length, float radius, float radiusEndCapLeft, float radiusEndCapRight)
        {
            float volEndCapLeft = 0, volEndCapRight = 0;
            float volC = RoundCylinderFullVolume(radius, length);

            if (radiusEndCapLeft > 0)
                volEndCapLeft = EndCapFullVolume(radiusEndCapLeft, radius);
            if (radiusEndCapRight > 0)
                volEndCapRight = EndCapFullVolume(radiusEndCapRight, radius);

            return volC + volEndCapRight + volEndCapLeft;
        }


        public static float TankRectangularFullVolume(float width, float height, float length)
        {
            return width * height * length;
        }


        public static float TankRectangularLevelVolume(float fillLevel, float width, float height, float length)
        {
            return width * fillLevel * length;//volume of tank is just a smaller tank with the value of height = fillLevel
        }


        public static float TankCircleFullVolume(float radius)
        {
            return 1.33333f * (float)Math.PI * Math.Pow(radius, 3);
        }

        public static float TankCircleLevelVolume(float height, float radius)
        {
            return (float)Math.PI * radius * Math.Pow(height, 2) - 0.33333f * (float)Math.PI * Math.Pow(height, 3);

            //Vy = πRy2−1/3πy3 
        }


        //Helper methods
        public static float RoundCylinderFullVolume(float radius, float length)
        {
            return (float)Math.PI * Math.Pow(radius, 2) * length;
        }

        public static float RoundCylinderPartialVolume(float height, float radius, float length)
        {
            return CirclePartialArea(height, radius) * length;
        }

        public static float VerticalRoundCylinderFullVolume(float height, float radius)
        {
            return VerticalRoundCylinderLevelVolume(height, radius);
        }

        public static float VerticalRoundCylinderLevelVolume(float height, float radius)
        {
            return (float)Math.PI * Math.Pow(radius, 2) * height;
        }

        public static float EndCapFullVolume(float minorRadius, float majorRadius)
        {
            return 2 * (float)Math.PI * Math.Pow(majorRadius, 2) * minorRadius / 3;
        }

        public static float EndCapPartialVolume(float height, float minorRadius, float majorRadius)
        {
            return 0.166666f * (3 * (float)Math.PI * majorRadius * minorRadius * Math.Pow(height, 2) -
                (float)Math.PI * minorRadius * Math.Pow(height, 3)) / majorRadius;
        }





        //Area Formulas Below

        private static float EndCapFullArea(float minorRadius, float majorRadius)
        {
            float r2Val = Math.Pow(minorRadius, 2);
            float R2Val = Math.Pow(majorRadius, 2);
            float SQRTRminrDivR = Math.Sqrt((R2Val - r2Val) / R2Val);

            return ((float)Math.PI * r2Val * Math.Atan(SQRTRminrDivR) + (float)Math.PI * R2Val * SQRTRminrDivR) / SQRTRminrDivR;
        }

        private static float CirclePartialArea(float height, float radius)
        {
            float radius2Val = Math.Pow(radius, 2);

            return (0.5f * (float)Math.PI * radius2Val) + radius2Val * Math.Asin((height - radius) / radius) -
                Math.Sqrt(2 * radius * height - Math.Pow(height, 2)) * (radius - height);
        }

        private static float CylinderRoundFullArea(float radius, float length)
        {
            return 2 * (float)Math.PI * radius * length;
        }

        private static float CylinderRoundContentSurfaceArea(float height, float radius, float L)
        {
            return 2 * L * Math.Sqrt((2 * radius - height) * height);
        }

        private static float EndCapContentSurfaceArea(float height, float minorRadius, float majorRadius)
        {
            return (float)Math.PI * (2 * majorRadius - height) * height * minorRadius / (2 * majorRadius);
        }



        /// <summary>
        /// Generates a ranodm intenger in the given range.
        /// </summary>
        /// <param name="min">Minium value from 0 - Int.max</param>
        /// <param name="max">Maximum value from 0 - Int.max</param>
        /// <returns></returns>
        public static int RandomNumber(int min, int max)
        {
            int low_num;
            int hi_num;
            if (min < max)
            {
                low_num = min;
                hi_num = max + 1; // include max in output.
            }
            else
            {
                low_num = max + 1;// include max in output.
                hi_num = min;
            }
            Random rand = new Random(DateTime.UtcNow.Millisecond);
            int result = rand.Next() % (hi_num - low_num) + low_num;
            return result;
        }


        /// <summary>Gets the int value of a hex char.</summary>
        /// <param name="ch">Hex char value</param>
        /// <returns>Integer value or -1 if invalid hex char is provided.</returns>
        public static int HexToInt(char ch)
        {
            return (ch >= '0' && ch <= '9') ? ch - '0' : (ch >= 'a' && ch <= 'f') ? ch - 'a' + 10 : (ch >= 'A' && ch <= 'F') ? ch - 'A' + 10 : -1;
        }



        private static readonly sbyte[] unhex_table =
                                              { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
                                               ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
                                               ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
                                               , 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,-1,-1,-1,-1,-1,-1
                                               ,-1,10,11,12,13,14,15,-1,-1,-1,-1,-1,-1,-1,-1,-1
                                               ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
                                               ,-1,10,11,12,13,14,15,-1,-1,-1,-1,-1,-1,-1,-1,-1
                                               ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
                                              };

        /// <summary>
        /// Converts hex string to an integer. 
        /// Ex:  ‭00294C77‬  -> ‭2706551‬
        /// </summary>
        /// <param name="hexNumber">Hex string without the 0x in it.</param>
        /// <returns>Integer value of hex string</returns>
        public static int HexStringToInt32(string hexNumber)
        {
            int decValue = unhex_table[(byte)hexNumber[0]];
            for (int i = 1; i < hexNumber.Length; i++)
            {
                decValue *= 16;
                decValue += unhex_table[(byte)hexNumber[i]];
            }
            return decValue;
        }


        public static short ByteToNumber(byte hexNumber)
        {
            byte[] bytes = { hexNumber, 0x00 };
            return BitConverter.ToInt16(bytes, 0);
        }

        public static string ByteToBitsString(byte byteIn)
        {
            var bitsString = new StringBuilder(8);

            bitsString.Append((byteIn / 128) % 2);
            bitsString.Append((byteIn / 64) % 2);
            bitsString.Append((byteIn / 32) % 2);
            bitsString.Append((byteIn / 16) % 2);
            bitsString.Append((byteIn / 8) % 2);
            bitsString.Append((byteIn / 4) % 2);
            bitsString.Append((byteIn / 2) % 2);
            bitsString.Append((byteIn / 1) % 2);

            return bitsString.ToString();
        }

        public static byte Bcd2Bin(byte val) { return (byte)(val - 6 * (val >> 4)); }

        public static byte Bin2Bcd(byte val) { return (byte)(val + 6 * (val / 10)); }

        public static byte DecToBcd(int val) { return (byte)((val / 10 * 16) + (val % 10)); }

        public static int BcdToDec(byte val) { return (val / 16 * 10) + (val % 16); }


        /// <summary>
        /// Returns day of week for a date
        /// </summary>
        public static int DayOfTheWeek(int year, int month, int day)
        {
            byte[] t = { 0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4 };
            if (month < 3)
                year--;//year -= month < 3; original code to be checked
            return (year + year / 4 - year / 100 + year / 400 + t[month - 1] + day) % 7;
        }

        /// <summary>
        /// Returns the date for Nth day of month, for example the 3rd Saturday of July
        /// </summary>
        public static int GetNthDayOfTheMonth(int year, int month, int dayofWeek, int nthWeek)
        {
            int targetDate = 1;
            int firstDOW = DayOfTheWeek(year, month, targetDate);

            while (firstDOW != dayofWeek)
            {
                firstDOW = (firstDOW + 1) % 7;
                targetDate++;
            }

            targetDate += (nthWeek - 1) * 7;
            return targetDate;
        }

        public static GpioPin GpioPort(int piNumber, PinMode mode, PinValue defaultPinValue)
        {
            GpioPin temp = GpioPort(piNumber, mode);
            temp.Write(defaultPinValue);
            return temp;
        }

        public static GpioPin GpioPort(int piNumber, PinMode mode)
        {
            GpioController GPIO = new GpioController();
            GpioPin temp = GPIO.OpenPin(piNumber);
            temp.SetPinMode(mode);
            return temp;
        }

        public static float ConvertTemperatureFromCtoF(float tempInC)
        {
            return tempInC * 1.8f + 32;// temp in F
        }

        public static char CRC16_LSB(byte[] pData, int length)
        {
            int pData_i = 0;

            if (length != 0)
            {
                char crc = (char)0xFFFF;

                do
                {
                    char data = (char)((char)0x00FF & pData[pData_i++]);
                    crc = (char)(crc ^ data);
                    for (byte i = 8; i > 0; i--)
                    {
                        if ((crc & 0x0001) != 0)
                            crc = (char)((crc >> 1) ^ 0x8408);
                        else
                            crc >>= 1;
                    }
                } while (--length != 0);

                crc = (char)~crc;

                return crc;
            }
            else
                return '0';
        }

    }
}